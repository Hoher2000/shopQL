package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"strconv"

	custom "github.com/Hoher2000/shopQL/customModels"
	"github.com/Hoher2000/shopQL/graph/model"
)

// Item is the resolver for the item field.
func (r *cartItemResolver) Item(ctx context.Context, obj *custom.CartItem) (*custom.Item, error) {	
	return r.Shop.ItemsMap[obj.ItemID], nil
}

// Quantity is the resolver for the quantity field.
func (r *cartItemResolver) Quantity(ctx context.Context, obj *custom.CartItem) (int, error) {
	return obj.Quantity, nil
}

// Childs is the resolver for the childs field.
func (r *catalogResolver) Childs(ctx context.Context, obj *custom.Catalog) ([]*custom.Catalog, error) {
	childs := make([]*custom.Catalog, len(obj.ChildsID))
	for i := range childs {
		childs[i] = r.Shop.CatalogsMap[obj.ChildsID[i]]
	}
	return childs, nil
}

// Parent is the resolver for the parent field.
func (r *catalogResolver) Parent(ctx context.Context, obj *custom.Catalog) (*custom.Catalog, error) {
	return r.Shop.CatalogsMap[*obj.ParentID], nil
}

// Items is the resolver for the items field.
func (r *catalogResolver) Items(ctx context.Context, obj *custom.Catalog, limit *int, offset *int) ([]*custom.Item, error) {
	items := make([]*custom.Item, len(obj.ItemsID))
	for i := range items {
		items[i] = r.Shop.ItemsMap[obj.ItemsID[i]]
	}
	return items[min(*offset, len(items)):min(*offset+*limit, len(items))], nil
}

// ItemsCount is the resolver for the itemsCount field.
func (r *catalogResolver) ItemsCount(ctx context.Context, obj *custom.Catalog) (int, error) {
	return obj.ItemsCount, nil
}

// InStockText is the resolver for the inStockText field.
func (r *itemResolver) InStockText(ctx context.Context, obj *custom.Item) (string, error) {
	var textCount string
	cnt := obj.InStock
	if cnt < 2 {
		textCount = "мало"
	} else if cnt < 4 {
		textCount = "хватает"
	} else {
		textCount = "много"
	}
	return textCount, nil
}

// InCart is the resolver for the inCart field.
func (r *itemResolver) InCart(ctx context.Context, obj *custom.Item) (int, error) {
	cnt := 0
	for _, item := range r.Cart {
		if obj.ID == item.ItemID {
			cnt = item.Quantity
			break
		}
	}
	return cnt, nil
}

// Seller is the resolver for the seller field.
func (r *itemResolver) Seller(ctx context.Context, obj *custom.Item) (*custom.Seller, error) {
	return r.Shop.SellersMap[obj.SellerID], nil
}

// Catalog is the resolver for the catalog field.
func (r *itemResolver) Catalog(ctx context.Context, obj *custom.Item) (*custom.Catalog, error) {
	return r.Shop.CatalogsMap[obj.CatalogID], nil
}

// Parent is the resolver for the parent field.
func (r *itemResolver) Parent(ctx context.Context, obj *custom.Item) (*custom.Catalog, error) {
	return r.Catalog(ctx, obj)
}

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, in model.CartItemInput) ([]*custom.CartItem, error) {
	id, err := strconv.Atoi(in.ItemID)
	if err != nil {
		return nil, err
	}
	r.Cart = append(r.Cart, &custom.CartItem{ItemID: id, Quantity: in.Quantity})
	return r.Cart, nil
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, in model.CartItemInput) ([]*custom.CartItem, error) {
	id, err := strconv.Atoi(in.ItemID)
	if err != nil {
		return nil, err
	}

	for i := range r.Cart {
		if r.Cart[i].ItemID == id {
			r.Cart[i].Quantity -= in.Quantity
			if r.Cart[i].Quantity < 1 {
				r.Cart = append(r.Cart[:i], r.Cart[i+1:]...)
			}
			break
		}
	}
	return r.Cart, nil
}

// Catalog is the resolver for the Catalog field.
func (r *queryResolver) Catalog(ctx context.Context, id string) (*custom.Catalog, error) {
	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Shop.CatalogsMap[idInt], nil
}

// Seller is the resolver for the Seller field.
func (r *queryResolver) Seller(ctx context.Context, id string) (*custom.Seller, error) {
	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	return r.Shop.SellersMap[idInt], nil
}

// MyCart is the resolver for the MyCart field.
func (r *queryResolver) MyCart(ctx context.Context) ([]*custom.CartItem, error) {
	return r.Cart, nil
}

// Items is the resolver for the items field.
func (r *sellerResolver) Items(ctx context.Context, obj *custom.Seller, limit *int, offset *int) ([]*custom.Item, error) {
	items := make([]*custom.Item, len(obj.ItemsID))
	for i := range items {
		items[i] = r.Shop.ItemsMap[obj.ItemsID[i]]
	}
	return items[min(*offset, len(items)):min(*offset+*limit, len(items))], nil
}

// CartItem returns CartItemResolver implementation.
func (r *Resolver) CartItem() CartItemResolver { return &cartItemResolver{r} }

// Catalog returns CatalogResolver implementation.
func (r *Resolver) Catalog() CatalogResolver { return &catalogResolver{r} }

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Seller returns SellerResolver implementation.
func (r *Resolver) Seller() SellerResolver { return &sellerResolver{r} }

type cartItemResolver struct{ *Resolver }
type catalogResolver struct{ *Resolver }
type itemResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sellerResolver struct{ *Resolver }
